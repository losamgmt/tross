#!/usr/bin/env node
/**
 * Generate ResourceType Dart Enum from Backend Entity Metadata
 *
 * This script generates the ResourceType enum in Dart from the backend
 * entity metadata, ensuring SSOT compliance. The generated enum replaces
 * the hardcoded version in permission.dart.
 *
 * Usage:
 *   node scripts/generate-resource-types.js
 *   npm run generate:resource-types
 *
 * Output:
 *   frontend/lib/generated/resource_type.dart
 */

const fs = require("fs");
const path = require("path");

// Shared utilities - DRY compliance
const { BACKEND_MODELS_DIR, RESOURCE_TYPE_DART } = require("./lib/paths");
const { snakeToCamel } = require("./lib/string-utils");

// Import SSOT: synthetic resources from permissions-deriver
const {
  SYNTHETIC_RESOURCES: SYNTHETIC_RESOURCES_MAP,
} = require("../backend/config/permissions-deriver");

// Import SSOT: parent-derived constant
const {
  RLS_RESOURCE_TYPES,
} = require("../backend/config/constants");

/**
 * Transform synthetic resources from permissions-deriver format to generator format.
 * Only includes synthetics that aren't already covered by entity metadata.
 *
 * @param {Set<string>} entityResources - Set of resource names from entity metadata
 * @returns {Array} Synthetic resources for Dart enum generation
 */
function getSyntheticResources(entityResources) {
  const synthetics = [];

  for (const [resourceName, config] of Object.entries(SYNTHETIC_RESOURCES_MAP)) {
    // Skip if this resource is already defined by entity metadata
    if (entityResources.has(resourceName)) {
      continue;
    }

    const camelName = snakeToCamel(resourceName);
    synthetics.push({
      name: camelName,
      snakeCase: resourceName === camelName ? null : resourceName,
      comment: config.description || null,
    });
  }

  // Add the parent-derived marker (special case - not a real resource)
  synthetics.push({
    name: "parentDerived",
    snakeCase: RLS_RESOURCE_TYPES.PARENT_DERIVED,
    comment:
      "Marker: entity derives permissions from parent context (e.g., file_attachment)",
  });

  return synthetics;
}

/**
 * Load all entity metadata files
 */
function loadEntityMetadata() {
  const entities = [];

  const files = fs.readdirSync(BACKEND_MODELS_DIR).filter((f) => {
    return f.endsWith("-metadata.js") && !f.includes(".types.");
  });

  for (const file of files) {
    const filePath = path.join(BACKEND_MODELS_DIR, file);
    try {
      // Clear require cache for fresh load
      delete require.cache[require.resolve(filePath)];
      const metadata = require(filePath);

      // Extract entity info
      const tableName = metadata.tableName;
      const resource = metadata.resource || tableName;
      const rlsResource = metadata.rlsResource;

      // Skip entities that derive permissions from parent
      // These use the special PARENT_DERIVED marker instead of a real resource
      const parentDerivedMarker = RLS_RESOURCE_TYPES.PARENT_DERIVED;
      if (rlsResource === parentDerivedMarker || resource === parentDerivedMarker) {
        console.log(`  Skipping ${tableName} (derives from parent)`);
        continue;
      }

      entities.push({
        tableName,
        resource,
        camelName: snakeToCamel(resource),
        needsSnakeCase: resource.includes("_"),
      });
    } catch (err) {
      console.error(`  Error loading ${file}: ${err.message}`);
    }
  }

  return entities;
}

/**
 * Generate the Dart enum code
 */
function generateDartEnum(entities, syntheticResources) {
  const timestamp = new Date().toISOString();

  // Sort entities alphabetically by camelCase name
  entities.sort((a, b) => a.camelName.localeCompare(b.camelName));

  let code = `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by scripts/generate-resource-types.js
// Generated at: ${timestamp}
//
// To regenerate, run: npm run generate:resource-types
// Source: backend/config/models/*-metadata.js

/// Resource types for permission checking
/// Maps to backend table names / permission resources
enum ResourceType {
  // ═══════════════════════════════════════════════════════════════════════════
  // Entity Resources (from backend metadata)
  // ═══════════════════════════════════════════════════════════════════════════
`;

  // Add entity resources
  for (const entity of entities) {
    if (entity.needsSnakeCase) {
      code += `  ${entity.camelName}('${entity.resource}'),\n`;
    } else {
      code += `  ${entity.camelName},\n`;
    }
  }

  code += `
  // ═══════════════════════════════════════════════════════════════════════════
  // Synthetic Resources (nav visibility, special-purpose)
  // ═══════════════════════════════════════════════════════════════════════════
`;

  // Add synthetic resources
  for (const synth of syntheticResources) {
    const comment = synth.comment ? ` // ${synth.comment}` : "";
    if (synth.snakeCase) {
      code += `  ${synth.name}('${synth.snakeCase}'),${comment}\n`;
    } else {
      code += `  ${synth.name},${comment}\n`;
    }
  }

  // Add enum body with methods
  code += `;

  final String? _value;
  const ResourceType([this._value]);

  /// Whether this is a real permission resource (vs a marker like parentDerived)
  bool get isRealResource => this != parentDerived;

  /// Get backend-compatible string (snake_case)
  String toBackendString() => _value ?? name;

  /// Get ResourceType from string (handles both camelCase and snake_case)
  static ResourceType? fromString(String? resource) {
    if (resource == null || resource.isEmpty) return null;
    final lower = resource.toLowerCase();
    return ResourceType.values.cast<ResourceType?>().firstWhere(
      (r) =>
          r?.name.toLowerCase() == lower ||
          r?.toBackendString().toLowerCase() == lower,
      orElse: () => null,
    );
  }

  /// Get all real resources (excludes markers like parentDerived)
  static List<ResourceType> get realResources =>
      values.where((r) => r.isRealResource).toList();

  @override
  String toString() => _value ?? name;
}
`;

  return code;
}

/**
 * Ensure output directory exists
 */
function ensureOutputDir() {
  const dir = path.dirname(RESOURCE_TYPE_DART);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    console.log(`Created directory: ${dir}`);
  }
}

/**
 * Main execution
 */
function main() {
  console.log("Generating ResourceType enum from backend metadata...\n");

  // Load entity metadata
  console.log("Loading entity metadata...");
  const entities = loadEntityMetadata();
  console.log(`  Found ${entities.length} entities\n`);

  // Build set of entity resource names (to exclude from synthetics)
  const entityResources = new Set(entities.map((e) => e.resource));

  // Get synthetic resources from SSOT (permissions-deriver)
  // Excludes any resources that are already covered by entity metadata
  const syntheticResources = getSyntheticResources(entityResources);

  // Generate Dart code
  console.log("Generating Dart enum...");
  const dartCode = generateDartEnum(entities, syntheticResources);

  // Write output
  ensureOutputDir();
  fs.writeFileSync(RESOURCE_TYPE_DART, dartCode);
  console.log(`  Written to: ${RESOURCE_TYPE_DART}\n`);

  // Summary
  console.log("Summary:");
  console.log(`  Entity resources: ${entities.length}`);
  console.log(`  Synthetic resources: ${syntheticResources.length}`);
  console.log(`  Total enum values: ${entities.length + syntheticResources.length}`);
  console.log("\nDone!");
}

main();
